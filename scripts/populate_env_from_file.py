#!/usr/bin/env python3
"""
Populate a local .env file from a provided env file (secure helper)

Usage:
  python3 scripts/populate_env_from_file.py --source paper_acct_env.env.txt --target .env.oanda_only --dry-run
  python3 scripts/populate_env_from_file.py --source paper_acct_env.env.txt --target .env.oanda_only --apply
  python3 scripts/populate_env_from_file.py --revert --target .env.oanda_only

Notes:
- This script masks secrets in dry-run mode. Using --apply will write the file and create a timestamped backup.
- The target file is NOT tracked by git if .gitignore is updated. Ensure you don't accidentally commit secrets.
"""
import argparse
import os
import stat
import sys
from datetime import datetime


MASK = "****REDACTED****"


def parse_env_file(path):
    d = {}
    with open(path, "r", encoding="utf-8") as f:
        for ln in f:
            ln = ln.strip()
            if not ln or ln.startswith("#"):
                continue
            if "=" in ln:
                k, v = ln.split("=", 1)
                d[k.strip()] = v.strip()
    return d


def mask_val(v: str):
    if not v:
        return v
    # mask long-looking tokens and account numbers
    if len(v) > 8:
        return v[:3] + MASK + v[-3:]
    return MASK


def write_env(path: str, mapping: dict):
    with open(path, "w", encoding="utf-8") as f:
        f.write("# Generated by scripts/populate_env_from_file.py - DO NOT commit secrets to source control\n")
        f.write("# Timestamp: %s\n\n" % datetime.utcnow().isoformat())
        for k, v in mapping.items():
            f.write(f"{k}={v}\n")
    # restrict permissions
    os.chmod(path, stat.S_IRUSR | stat.S_IWUSR)


def backup_file(path: str):
    if not os.path.exists(path):
        return None
    ts = int(datetime.utcnow().timestamp())
    bak = f"{path}.bak-{ts}"
    os.rename(path, bak)
    return bak


def restore_backup(bak_path: str, target: str):
    if not os.path.exists(bak_path):
        raise FileNotFoundError(f"Backup not found: {bak_path}")
    if os.path.exists(target):
        os.remove(target)
    os.rename(bak_path, target)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--source", help="Source file to parse (env file)")
    parser.add_argument("--target", default=".env.oanda_only", help="Target file to write (default .env.oanda_only)")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be written (masked)")
    parser.add_argument("--apply", action="store_true", help="Apply the changes and write the target file")
    parser.add_argument("--revert", action="store_true", help="Revert using the most recent backup")
    args = parser.parse_args()

    if args.revert:
        # find most recent backup matching target
        dirpath = os.path.dirname(args.target) or "."
        basename = os.path.basename(args.target)
        cands = [f for f in os.listdir(dirpath) if f.startswith(basename + ".bak-")]
        if not cands:
            print("No backups found to revert")
            sys.exit(1)
        cands.sort()
        bak = os.path.join(dirpath, cands[-1])
        restore_backup(bak, args.target)
        print(f"Restored backup {bak} -> {args.target}")
        sys.exit(0)

    if not args.source:
        parser.print_help()
        sys.exit(1)

    mapping = parse_env_file(args.source)
    if args.dry_run or not args.apply:
        # show summary and masked values
        print(f"Dry-run: Prepared to write {len(mapping)} entries to {args.target}")
        simple_keys = [
            'RICK_PIN', 'OANDA_PRACTICE_ACCOUNT_ID', 'OANDA_PRACTICE_TOKEN', 'OANDA_LIVE_TOKEN',
            'COINBASE_SANDBOX_API_KEY', 'COINBASE_SANDBOX_API_SECRET', 'TELEGRAM_BOT_TOKEN'
        ]
        for k in sorted(mapping.keys()):
            v = mapping[k]
            if k in simple_keys or any(x in k for x in ['TOKEN', 'SECRET', 'KEY', 'PASSWORD', 'PASSPHRASE']):
                print(f"{k}={mask_val(v)}")
            else:
                print(f"{k}={v}")
        print("\nDry-run complete. To apply run with --apply")
        sys.exit(0)

    # apply mode
    # backup existing target
    bak = backup_file(args.target)
    if bak:
        print(f"Backed up existing {args.target} -> {bak}")
    write_env(args.target, mapping)
    print(f"Wrote {len(mapping)} entries to {args.target}")


if __name__ == '__main__':
    main()
